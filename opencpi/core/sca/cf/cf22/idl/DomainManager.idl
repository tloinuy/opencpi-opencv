
/*
 *  Copyright (c) Mercury Federal Systems, Inc., Arlington VA., 2009-2010
 *
 *    Mercury Federal Systems, Incorporated
 *    1901 South Bell Street
 *    Suite 402
 *    Arlington, Virginia 22202
 *    United States of America
 *    Telephone 703-413-0781
 *    FAX 703-413-0784
 *
 *  This file is part of OpenCPI (www.opencpi.org).
 *     ____                   __________   ____
 *    / __ \____  ___  ____  / ____/ __ \ /  _/ ____  _________ _
 *   / / / / __ \/ _ \/ __ \/ /   / /_/ / / /  / __ \/ ___/ __ `/
 *  / /_/ / /_/ /  __/ / / / /___/ ____/_/ / _/ /_/ / /  / /_/ /
 *  \____/ .___/\___/_/ /_/\____/_/    /___/(_)____/_/   \__, /
 *      /_/                                             /____/
 *
 *  OpenCPI is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  OpenCPI is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with OpenCPI.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _DOMAINMANAGER_IDL
#define _DOMAINMANAGER_IDL

//#include "PropertySet.idl"
//#include "Resource.idl"
#include "DeviceManager.idl"
/*#include "FileManager.idl"
#include "InvalidObjectReference.idl"
#include "Device.idl"
*/
module CF
{
  interface Application;
  interface ApplicationFactory;

	/* The DomainManager interface API is for the control and configuration of the
	radio domain.
	
	The DomainManager interface can be logically grouped into three categories:
	Human Computer Interface (HCI), Registration, and Core Framework (CF) administration.
	1. The HCI operations are used to configure the domain, get the domain's capabilities
	(Devices, Services, and Applications), and initiate maintenance functions.
	Host operations are performed by a client user interface capable of interfacing to the
	Domain Manager.
	2. The registration operations are used to register / unregister DeviceManagers,
	DeviceManager's Devices, DeviceManager's Services, and Applications at startup or
	during run-time for dynamic device, service, and application extraction and insertion.
	
	3. The administration operations are used to access the interfaces of registered
	DeviceManagers, FileManagers, and Loggers of the domain.
	
	During component construction the DomainManager registers itself
	with the CORBA Naming Service.  During Naming Service registration the
	DomainManager creates a "naming context" using "/DomainName"
	as its name.ID component and "" (Null string) as its name.kind component,
	then create a "name binding" to the "/DomainName" naming context using
	"/DomainManager" as its name.ID component, "" (Null string) as its name.kind
	component, and the DomainManager's object reference.   (See also 3.1.3.2.2.5.1.3)
	Since a log service is not a required component of a JTRS installation, a
	DomainManager implementation may, or may not have access to a Log.
	However, if log service(s) are available, a DomainManager implementation
	may use one or more of them.The Logs utilized by the DomainManager
	implementation shall be defined in the DMD.  See Appendix D for further
	description of the DMD file.
	
	Once a service specified in the DMD is successfully registered with the
	DomainManager (via registerDeviceManager or registerService operations),
	the DomainManager  begins to use the service (e.g., Log).
	The DomainManager creates its own FileManager component that consists
	of all registered DeviceManager's FileSystems.
	The DomainManager restores ApplicationFactories after startup for applications
	that were previously installed by the DomainManager installApplication operation.
	The DomainManager adds the restored ApplicationFactories to the
	DomainManager's applicationFactories attribute.
	The DomainManager creates the Incoming Domain Management and
	Outgoing Domain Management event channels */
	
	interface DomainManager : PropertySet {
		/* The ApplicationInstallationError exception type is raised when an Application installation 
		has not completed correctly. The error number  indicates an ErrorNumberType value (e.g., EINVAL, 
		ENAMETOOLONG , ENOENT, ENOMEM, ENOSPC, ENOTDIR, ENXIO). The message is component-dependent, 
		providing additional information describing the reason for the error. */
		
		exception ApplicationInstallationError {
			ErrorNumberType errorNumber;
			string msg;
		};
		
		/* This type defines an unbounded sequence of Applications. */
		
		typedef sequence <Application> ApplicationSequence;
		
		/* This type defines an unbounded sequence of application factories. */
		
		typedef sequence <ApplicationFactory> ApplicationFactorySequence;
		
		/* This type defines an unbounded sequence of device managers. */
		
		typedef sequence <DeviceManager> DeviceManagerSequence;
		
		/* This exception indicates the application ID is invalid. */
		
		exception InvalidIdentifier {
		};
		
		/* The DeviceManagerNotRegistered exception indicates the registering Device's DeviceManager 
		is not registered in the DomainManager. A Device's DeviceManager has to be registered prior 
		to a Device registration to the DomainManager. */
		
		exception DeviceManagerNotRegistered {
		};
		
		/* The ApplicationUninstallationError exception type is raised when an Application uninstallation 
		has not completed correctly. The error number indicates an ErrorNumberType value. The message is 
		component-dependent, providing additional information describing the reason for the error. */
		
		exception ApplicationUninstallationError {
			ErrorNumberType errorNumber;
			string msg;
		};
		
		/* The RegisterError exception indicates that an internal error has occurred to prevent DomainManager 
		registration operations from successful completion. The error number indicates an ErrorNumberType value. 
		The message is component-dependent, providing additional information describing the reason for the error. */
		
		exception RegisterError {
			ErrorNumberType errorNumber;
			string msg;
		};
		
		/* The UnregisterError exception indicates that an internal error has occurred to prevent 
		DomainManager unregister operations from successful completion. The error number indicates an 
		ErrorNumberType value. The message is component-dependent, providing additional information 
		describing the reason for the error. */
		
		exception UnregisterError {
			ErrorNumberType errorNumber;
			string msg;
		};
		
		/* The AlreadyConnected exception indicates that a registering consumer is already connected to 
		the specified event channel. */
		
		exception AlreadyConnected {
		};
		
		/* The InvalidEventChannelName exception indicates that a DomainManager was not able to locate 
		the event channel. */
		
		exception InvalidEventChannelName {
		};
		
		/* The NotConnected exception indicates that the unregistering consumer was not connected to the 
		specified event channel. */
		
		exception NotConnected {
		};
		
		/* The domainManagerProfile attribute contains the DomainManager's profile.
		The readonly domainManagerProfile attribute contains either a profile element with a file reference 
		to the DomainManager's  (DMD) profile or the XML for the
		DomainManager's (DMD) profile.  Files referenced within the profile will have to be obtained from 
		the DomainManager's FileManager. */
		
		readonly attribute string domainManagerProfile;
		/* The deviceManagers attribute is read-only containing a sequence of registered DeviceManagers in 
		the domain.  The DomainManager contains a list of registered DeviceManagers that have registered with 
		the DomainManager.  The DomainManager writes an ADMINISTRATIVE_EVENT log to a DomainManager's Log, 
		when the deviceManagers attribute is obtained by a client. */
		
		readonly attribute DeviceManagerSequence deviceManagers;
		/* The applications attribute is read-only containing a sequence of instantiated Applications in 
		the domain.  The DomainManager contains a list of Applications that have been instantiated. The 
		DomainManager writes an ADMINISTRATIVE_EVENT log record to a DomainManager's Log, when the 
		applications attribute is obtained by a client. */
		
		readonly attribute ApplicationSequence applications;
		/* The readonly applicationFactories attribute contains a list with one ApplicationFactory per 
		application (SAD file and associated files) successfully installed (i.e. no exception raised).  
		The DomainManager writes an ADMINISTRATIVE_EVENT log record to a DomainManager's Log, when the 
		applicationFactories attribute is obtained by a client. */
		
		readonly attribute ApplicationFactorySequence applicationFactories;
		/* The fileMgr attribute is read only containing the mounted FileSystems in the domain.  The 
		DomainManager writes an ADMINISTRATIVE_EVENT log record to a DomainManager's Log, when the 
		fileMgr attribute is obtained by a client. */
		
		readonly attribute FileManager fileMgr;
		/* The readonly identifier attribute contains a unique identifier for a DomainManager instance. 
		The identifier is identical to the domainmanagerconfiguration element id attribute of the DomainManager's 
		Descriptor (DMD) file. */
		
		readonly attribute string identifier;
		
		/* The registerDevice operation verifies that the input parameters, registeringDevice and registeredDeviceMgr, 
		are not nil CORBA component references.
	
		The registerDevice operation adds the registeringDevice and the registeringDevice's attributes  
		(e.g., identifier, softwareProfile's allocation properties, etc.) to the 
		DomainManager, if it does not already exist.  
	
		The registerDevice operation associates the input registeringDevice with the input registeredDeviceMgr 
		in the DomainManager when the input registeredDeviceMgr is a 
		valid registered DeviceManager in the DomainManager.

		When the registering Device's parent DeviceManager's DCD describes service connections for the registering 
		Device, the registerDevice operation shall establish the connections.
	
		The registerDevice operation, upon successful device registration, writes an ADMINISTRATIVE_EVENT log 
		record to a DomainManager's Log, to indicate that the device has successfully registered with the DomainManager.
	
		Upon unsuccessful device registration, the registerDevice operation writes a FAILURE_ALARM log record to a 
		DomainManager's Log, when the InvalidProfile exception is raised to indicate that the 
		registeringDevice has an invalid profile.

	
		Upon unsuccessful device registration, the registerDevice operation logs a Failure_Alarm event with 
		DomainManager's Logger for the DeviceManagerNotRegistered exception to indicate that the device that 
		cannot be registered to the Device due to the DeviceManager is not registered with the DomainManager.
	
		Upon unsuccessful device registration, the registerDevice operation writes a FAILURE_ALARM log record to a 
		DomainManager's Log,  indicating that the device could not register because the DeviceManager is not 
		registered with the DomainManager.

		Upon unsuccessful device registration, the registerDevice operation writes a FAILURE_ALARM log record to a 
		DomainManager's Log, because of an invalid reference input parameter.


		Upon unsuccessful device registration, the registerDevice operation shall write a FAILURE_ALARM log 
		record to a DomainManager's Log, because of an internal registration error.

		The registerDevice operation, upon successful Device registration, sends an event to the Outgoing 
		Domain Management event channel with event data consisting of a DomainManagementObjectAddedEventType. 
		The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the DomainManager.
		2.	The sourceId is the identifier attribute of the registered Device.
		3.	The sourceName is the label attribute of the registered Device.
		4.	The sourceIOR is the registered Device object reference.
		5.	The sourceCategory is DEVICE.


		The registerDevice operation raises the CF InvalidProfile exception when: 
		1. The Device's SPD file and the SPD's referenced files do not exist or cannot be processed due to the 
		file not being compliant with XML syntax, or
		2. The Device's SPD does not reference allocation properties.
	
		The registerDevice operation raises a DeviceManagerNotRegistered exception when 
		the input registeredDeviceMgr (not nil reference) is not registered with the DomainManager. 

		The registerDevice operation raises the CF InvalidObjectReference exception when input parameters 
		registeringDevice or registeredDeviceMgr contains an invalid reference.

		The registerDevice operation raises the RegisterError exception when an internal error exists which 
		causes an unsuccessful registration.
		@roseuid 364B4CF92ED0 */
		void registerDevice (
			in Device registeringDevice,
			in DeviceManager registeredDeviceMgr
			)			
			raises (InvalidObjectReference, InvalidProfile, DeviceManagerNotRegistered, RegisterError);
			
		/* The registerDeviceManager operation verifies that the input parameter, deviceMgr, 
		is a not a nil CORBA component reference.

		The registerDeviceManager operation adds the input deviceMgr to the DomainManager's deviceManagers 
		attribute, if it does not already exist.  The registerDeviceManager operation adds the 
		input deviceMgr's registeredDevices and each registeredDevice's attributes  (e.g., identifier, softwareProfile's 
		allocation properties, etc.) to the DomainManager.  The registerDeviceManager operation 
		associates the input deviceMgr's with the input deviceMgr's registeredDevices in the 
		DomainManager in order to support the unregisterDeviceManager operation.

		The registerDeviceManager operation adds the input deviceMgr's registeredServices and each 
		registeredService's names to the DomainManager.  The registerDeviceManager operation associates 
		the input deviceMgr's with the input deviceMgr's registeredServices in the DomainManager in 
		order to support the unregisterDeviceManager operation.
		The registerDeviceManager operation performs the  connections as specified in the connections 
		element of the deviceMgr's Device Configuration Descriptor (DCD) file.  If the DeviceManager's 
		Device Configuration Descriptor (DCD) describes a connection for a service that has not been 
		registered with the DomainManager, the registerDeviceManager operation establishes any pending 
		connection when the service registers with the DomainManager by the registerDeviceManager operation. 

		For connections established for a CORBA Event Service's event channel, the registerDeviceManager 
		operation connects a CosEventComm PushConsumer or PushSupplier object to the event channel as 
		specified in the DCD's domainfinder element. If the event channel does not exist, the 
		registerDeviceManager operation creates the event channel.

		The registerDeviceManager operation obtains all the Software profiles from the registering 
		DeviceManager's FileSystems.

		The registerDeviceManager operation mounts the DeviceManager's FileSystem to the DomainManager's 
		FileManager.  The mounted FileSystem name will have the format, "/DomainName/HostName", 
		where DomainName is the name of the domain and HostName is the input deviceMgr's label attribute.

		The registerDeviceManager operation, upon unsuccessful DeviceManager registration, writes a 
		FAILURE_ALARM log record to a DomainManager's Log.

		The registerDeviceManager operation, upon successful DeviceManager registration, 
		sends an event to the Outgoing Domain Management event channel with event data 
		consisting of a DomainManagementObjectAddedEventType. The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the DomainManager.
		2.	The sourceId is the identifier attribute of the registered DeviceManager.
		3.	The sourceName is the label attribute of the registered DeviceManager.
		4.	The sourceIOR is the registered DeviceManager object reference.
		5.	The sourceCategory is DEVICE_MANAGER


		The registerDeviceManager operation raises the CF InvalidObjectReference exception when the 
		input parameter deviceMgr contains an invalid reference to a DeviceManager interface.
		The registerDeviceManager operation raises the RegisterError exception when an internal 
		error exists which causes an unsuccessful registration.
		@roseuid 364B4D632938 */
		void registerDeviceManager (
			in DeviceManager deviceMgr
			)			
			raises (InvalidObjectReference, InvalidProfile, RegisterError);
			
		/* The unregisterDeviceManager operation is used to unregister a DeviceManager 
		component from the DomainManager's Domain Profile.  A DeviceManager may be unregistered 
		during run-time for dynamic extraction or maintenance of the DeviceManager.
		
		The unregisterDeviceManager operation unregisters a DeviceManager component from the DomainManager.
		The unregisterDeviceManager operation releases (client-side CORBA release) all device(s) and 
		service(s) associated with the DeviceManager that is being unregistered.
		
		The unregisterDeviceManager operation disconnects consumers and producers (e.g., Devices, Log,
		DeviceManager, etc.) from a CORBA Event Service event channel based upon the software profile.  
		The unregisterDeviceManager operation may destroy the CORBA Event Service event channel when no 
		more consumers and producers are connected to it.
		
		The unregisterDeviceManager operation shall unmount all DeviceManager's FileSystems from its File Manager.
		The unregisterDeviceManager operation, upon the successful unregistration of a DeviceManager, 
		writes an ADMINISTRATIVE_EVENT log record to a DomainManager's Log. 

		The unregisterDeviceManager operation, upon unsuccessful unregistration of a DeviceManager, 
		writes a FAILURE_ALARM log record to a DomainManager's Log.

		The unregisterDeviceManager operation, upon successful unregistration, 
		sends an event to the Outgoing Domain Management event channel with event data 
		consisting of a DomainManagementObjectRemovedEventType. The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the DomainManager.
		2.	The sourceId is the identifier attribute of the unregistered DeviceManager.
		3.	The sourceName is the label attribute of the unregistered DeviceManager.
		4.	The sourceCategory is DEVICE_MANAGER.


		The unregisterDeviceManager operation raises the CF InvalidObjectReference when 
		the input parameter DeviceManager contains an invalid reference to a DeviceManager interface.

		The unregisterDeviceManager operation raises the UnregisterError exception when an 
		internal error exists which causes an unsuccessful unregistration.
		@roseuid 364B4EAB15E0 */
		void unregisterDeviceManager (
			in DeviceManager deviceMgr
			)			
			raises (InvalidObjectReference, UnregisterError);
			
		/* The unregisterDevice operation is used to remove a device entry from the 
		DomainManager for a specific DeviceManager.

		The unregisterDevice operation releases (client-side CORBA release) the 
		unregisteringDevice from the DomainManager.

		The unregisterDevice operation disconnects the Device's consumers and producers from a 
		CORBA Event Service event channel based upon the software profile. The unregisterDevice 
		operation may destroy the CORBA Event Service event channel when no more consumers and 
		producers are connected to it.

		The unregisterDevice operation, upon the successful unregistration of a Device, 
		writes an ADMINISTRATIVE_EVENT log record to a DomainManager's Log.

		The unregisterDevice operation, upon unsuccessful unregistration of a Device, 
		writes a FAILURE_ALARM log record to a DomainManager's Log.

		The unregisterDevice operation, upon successful Device unregistration, sends an event to 
		the Outgoing Domain Management event channel with event data consisting of a 
		DomainManagementObjectRemovedEventType. The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the DomainManager.
		2.	The sourceId is the identifier attribute of the unregistered Device.
		3.	The sourceName is the lable attribute of the unregistered Device.
		4.	The sourceCategory is DEVICE.


	The unregisterDevice operation raises the CF InvalidObjectReference exception 
	when the input parameter contains an invalid reference to a Device interface.

	The unregisterDevice operation raises the UnregisterError exception whan an internal error 
	exists which causes an unsuccessful unregistration.
		@roseuid 364B4EC8DEC0 */
		void unregisterDevice (
			in Device unregisteringDevice
			)			
			raises (InvalidObjectReference, UnregisterError);
			
		/* This operation is used to register new application software in the DomainManager. 
		An installer application typically invokes this operation when it has completed the 
		installation of a new Application into the domain.

		The profileFileName is the absolute path of the profile filename.

		The installApplication operation verifies the application's SAD file exists in the
		DomainManager's FileManager and all the files the application is dependent on are also resident.

		The installApplication operation writes an ADMINISTRATIVE_EVENT log Record to a 
		DomainManager's Log, upon successful Application installation.

		The installApplication operation, upon successful application installation, sends an 
		event to the Outgoing Domain Management event channel with event data consisting of a 
		DomainManagementObjectAddedEventType. The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the DomainManager.
		2.	The sourceId is the identifier attribute of the installed ApplicationFactory.
		3.	The sourceName is the name attribute of the installed ApplicationFactory.
		4.	The sourceIOR is the installed ApplicationFactory object reference.
		5.	The sourceCategory is  APPLICATION_FACTORY.



		The installApplication operation raises the ApplicationInstallationError exception 
		when the installation of the Application file(s) was not successfully completed.

		The installApplication operation raises the CF InvalidFileName exception when the 
		input SAD file or any referenced file name does not exist in the file system as 
		defined in the absolute path of the input profileFileName.  The installApplication operation 
		logs a FAILURE_ALARM log record to a DomainManger's Log when the InvalidFileName exception 
		occurs and the logged message shall be "installApplication:: invalid file is xxx", where "xxx" 
		is the input or referenced file name is bad.

		The installApplication operation raises the CF InvalidProfile exception when the input SAD 
		file or any referenced file is not compliant with XML DTDs defined in Appendix D or referenced 
		property definitions are missing.  The installApplication operation s logs a FAILURE_ALRAM log 
		record ot a DomainManager's Log when the CF InvalidProfile exception occurs and the logged message 
		shall be "installApplication:: invalid Profile is yyy," where "yyy" is and the input or referenced 
		file name that is bad along with the element or position within the profile that is bad.
		@roseuid 3896F0D83588 */
		void installApplication (
			in string profileFileName
			)			
			raises (InvalidProfile, InvalidFileName, ApplicationInstallationError);
			
		/* This operation is used to uninstall an application from the DomainManager.
		The CF Installer typically invokes this operation when removing an application from the radio domain.

		The ApplicationID parameter is the softwareassembly element id attribute of the 
		ApplicationFactory's Software Assembly Descriptor file.

		The uninstallApplication operation removes all files associated with the Application.

		The uninstallApplication operation makes the ApplicationFactory unavailable from the 
		DomainManager (i.e. its services no longer provided for the Application).

		The uninstallApplication operation, upon successful uninstall of an Application, 
		writes an ADMINISTRATIVE_EVENT log record to a DomainManager's Log.

		The uninstallApplication operation, upon unsuccessful uninstall of an  Application, 
		writes a FAILURE_ALARM log record to a DomainManager's Log.


		The uninstallAppllication operation, upon successful uninstall of an application, 
		sends an event to the Outgoing Domain Management event channel with event data consisting 
		of a DomainManagementObjectRemovedEventType. The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the DomainManager.
		2.	The sourceId is the identifier attribute of the uninstalled ApplicationFactory.
		3.	The sourceName is the name attribute of the uninstalled ApplicationFactory.
		4.	The sourceCategory is APPLICATION_FACTORY.


		The uninstallApplication operation  raises the InvalidIdentifier exception when the 
		ApplicationId is invalid.

		The uninstallApplication operation raises the ApplicationUninstallationError exception 
		when an internal error causes unsuccessful uninstall of the application.
		@roseuid 3896F13747C8 */
		void uninstallApplication (
			in string applicationId
			)			
			raises (InvalidIdentifier, ApplicationUninstallationError);
			
		/* This operation is used to register a service for a specific DeviceManager with the DomainManager.
		The registerService operation verifies the input registeringService and registeredDeviceMgr 
		are valid object references.
		
		The registerService operation verifies the input registeredDeviceMgr has been previously 
		registered with the DomainManager.
		The registerService operation adds the registeringService's object reference and the 
		registeringService's name to the DomainManager, if the name for the type of  service being registered 
		does not exist within the DomainManager.  However, if the name of the registering service is a 
		duplicate of a registered service of the same type, then the new service is not registered with the DomainManager. 
		The registerService operation associates the input registeringService parameter with the 
		input registeredDeviceMgr parameter in the DomainManager's, when the registeredDeviceMgr 
		parameter indicates aa DeviceManager registered with the DomainManager.

		The registerService operation, upon successful service registration, establishes any 
		pending connection requests for the registeringService. The registerService operation, 
		upon successful service registration, writes an ADMINISTRATIVE_EVENT log record to a DomainManager's Log.
		The registerService operation, upon unsuccessful service registration, writes a FAILURE_ALARM 
		log record to a DomainManager's Log.
		The registerService operation, upon successful service registration, sends an event to the 
		Outgoing Domain Management event channel with event data consisting of a 
		DomainManagementObjectAddedEventType. The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the DomainManager.
		2.	The sourceId is the identifier attribur from the componentinstantiation element associated with the registered service.
		3.	The sourceName is the input name parameter for the registering service.
		4.	The sourceIOR is the registered service object reference.
		5.	The sourceCategory is SERVICE.

		This operation does not return a value.

		The registerService operation raises a DeviceManagerNotRegistered exception when the input 
		registeredDeviceMgr parameter  is not a nil reference and is not registered with the DomainManager.
		The registerService operation raises the CF InvalidObjectReference exception when input 
		parameters registeringService or registeredDeviceMgr contains an invalid reference.
		The registerService operation raises the RegisterError exception whn an internal error 
		exists which causes an unsuccessful registration.
		@roseuid 3B33926D032F */
		void registerService (
			in Object registeringService,
			in DeviceManager registeredDeviceMgr,
			in string name
			)			
			raises (InvalidObjectReference, InvalidProfile, DeviceManagerNotRegistered, RegisterError);
			
		/* This operation is used to remove a service entry from the DomainManager for a specific DeviceManager.
		
		The unregisterService operation removes the unregisteringService  entry specified by the input parameter 
		from the DomainManager.

		The unregisterService operation releases (client-side CORBA release) the 
		unregisteringService from the DomainManager.

		The unregisterService operation, upon the successful unregistration of a Service, 
		writes an ADMINISTRATIVE_EVENT log record to a DomainManager's Log.
		
		The unregisterService operation, upon unsuccessful unregistration of a Service, writes a 
		FAILURE_ALARM log record to a DomainManager's Log.
		The unregisterService operation, upon successful service unregistration, sends an event 
		to the Outgoing Domain Management event channel with event data consisting of a 
		DomainManagementObjectRemovedEventType. The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the DomainManager.
		2.	The sourceId is  the ID attribute from the componentinstantiation element associated with the unregistered service.
		3.	The sourceName is  the input name parameter for the unregistering service.
		4.	The sourceCategory is SERVICE. 

		This operation does not return a value.

		The unregisterService operation raises the CF InvalidObjectReference exception when the 
		input parameter contains an invalid reference to a Service interface.

		The unregisterService operation raises the UnregisterError exception when an internal error 
		exists which causes an unsuccessful unregistration.
		@roseuid 3B3392750114 */
		void unregisterService (
			in Object unregisteringService,
			in string name
			)			
			raises (InvalidObjectReference, UnregisterError);
			
		/* The registerWithEventChannel operation is used to connect a consumer to a domain's event channel.
		
		The registerWithEventChannel operation connects the input registeringConsumer to event channel as 
		specified by the input eventChannelName.

		This operation does not return a value.

		The registerWithEventChannel operation raises the CF InvalidObjectReference exception 
		when the input parameter contains an invalid reference to a CosEventComm PushConsumer interface.
		The registerWithEventChannel operation raises the InvalidEventChannelName exception when the 
		input parameter contains an invalid event channel name (e.g, "ODM_Channel").
		The registerWithEventChannel operation raises AlreadyConnected exception when the input 
		parameter contains a connection to the event channel for the input registeringConsumerId parameter.
		@roseuid 3BB49D7901AE */
		void registerWithEventChannel (
			in Object registeringObject,
			in string registeringId,
			in string eventChannelName
			)			
			raises (InvalidObjectReference, InvalidEventChannelName, AlreadyConnected);
			
		/* The unregisterFromEventChannel operation is used to disconnect a consumer 
		from a domain's event channel.

		The unregisterFromEventChannel operation shall disconnect a registered consumer from 
		the event channel as identified by the input parameters.

		This operation does not return a value.

		The unregisterFromEventChannel operation raises the InvalidEventChannelName exception 
		when the input parameter contains an invalid reference to an event channel (e.g., "ODM_Channel").
		The unregisterWithEventChannel operation raises NotConnected exception when the input 
		parameter registeringConsumerId parameter is not connected to specified input event channel.
		@roseuid 3BB49DF903CF */
		void unregisterFromEventChannel (
			in string unregisteringId,
			in string eventChannelName
			)			
			raises (InvalidEventChannelName, NotConnected);
			
	};



	/* This type defines an unbounded sequence of Devices.
	
	The IDL to Ada mapping has a problem with self referential interfaces.
	To get around this problem, the interface Device forward declaration has been created
	and this type has been moved outside of the Device interface. */
/*	
	typedef sequence <Device> DeviceSequence;
*/
	/* DeviceAssignmentType defines a structure that associates a component
	with the Device upon which the component is executing on. */
	
	struct DeviceAssignmentType {
		string componentId;
		string assignedDeviceId;
	};

	/* This exception indicates an invalid component profile error. */
	
	/* The IDL sequence, DeviceAssignmentSequence, provides a unbounded
	sequence of 0..n of DeviceAssignmentType. */
	
	typedef sequence <DeviceAssignmentType> DeviceAssignmentSequence;
	
	/* The ApplicationFactory interface class provides an interface to request the
	creation of a specific type  (e.g., SINCGARS, LOS, Havequick, etc.) of
	Application in the domain. The ApplicationFactory interface class is designed
	using the Factory Design Pattern.  The Software Profile determines the type of
	Application that is created by the ApplicationFactory. */
	
	interface ApplicationFactory {
		/* This exception is raised when the parameter DeviceAssignmentSequence contains one (1) or more 
		invalid Application component-to-device assignment(s). */
		
		exception CreateApplicationRequestError {
			DeviceAssignmentSequence invalidAssignments;
		};

		/* The CreateApplicationError exception is raised when a create request is valid but the Application 
		is unsuccessfully instantiated due to internal processing errors. The error number indicates an 
		ErrorNumberType value (e.g., E2BIG, ENAMETOOLONG, ENFILE, ENODEV, ENOENT, ENOEXEC, ENOMEM, ENOTDIR, 
		ENXIO, EPERM). The message is component-dependent, providing additional information describing the 
		reason for the error. */
		
		exception CreateApplicationError {
			ErrorNumberType errorNumber;
			string msg;
		};
		
		/* The invalidInitConfiguration exception is raised when the input initConfiguration 
		parameter is invalid. */
		
		exception InvalidInitConfiguration {
			Properties invalidProperties;
		};
		
		/* The name attribute contains the name of the type of Application that can be instantiated 
		by the ApplicationFactory (e.g., SINCGARS, LOS, Havequick, DAMA25, etc.). */
		
		readonly attribute string name;
		/* The readonly identifier attribute contains the unique identifier for an ApplicationFactory 
		instance. The identifier is identical to the softwareassembly element id attribute of the 
		ApplicationFactory's Software Assembly Descriptor file. */
		
		readonly attribute string identifier;
		/* This attribute contains the application software profile that this factory uses when 
		creating an application.  The string value contains either a profile element with a file 
		reference to the SAD
		profile file or the actual xml for the SAD profile.  Files referenced within the profile 
		will have to be obtained from a FileManager.  The ApplicationFactory will have to be queried 
		for profile information for Component files that are referenced by an ID instead of file
		name. */
		
		readonly attribute string softwareProfile;
		
		/* This operation is used to create an Application within the system domain. 
		The create operation provides a client interface to request the creation of an Application on 
		client requested device(s) or the creation of an Application in which the ApplicationFactory 
		determines the necessary device(s) required for instantiation of the Application.

		An Application can be comprised of one or more components (e.g., Resources, Devices, etc.).  
		The SAD contains Software Package Descriptors (SPDs) for each Application component.  The 
		SPD specifies the Device implementation criteria for loading dependencies (processor kind, etc.) 
		and processing capacities (e.g., memory, process) for an application component.  The create 
		operation uses the SAD SPD implementation element to locate candidate devices capable of 
		loading and executing Application components.
		If deviceAssignments (not zero length) are provided, the ApplicationFactory verifies each device 
		assignment, for the specified component, against the component's SPD implementation element.
		The create operation allocates (Device allocateCapacity) component capacity requirements against 
		candidate devices to determine which candidate devices satisfy all SPD implementation criteria 
		requirements and SAD partitioning requirements (e.g., components HostCollocation, etc.).  The 
		create operation only uses Devices that have been granted successful capacity allocations for 
		loading and executing Application components, or used for data processing. The actual Devices 
		chosen will reflect changes in capacity based upon component capacity requirements allocated to 
		them, which may also cause state changes for the Devices.

		The create operation loads the Application components (including all of the 
		Application-dependent components) to the chosen device(s).
		The create operation executes the application components (including all of the application-dependent 
		components) as specified in the application's Software Assembly Descriptor (SAD) file.
		The create operation uses each component's SPD implementation code's stack size and priority elements, 
		when specified, for the execute options parameters.  
		The create operation passes the mandatory execute parameters of a Naming Context IOR, 
		Name Binding, and the identifier for the component in the form of CF Properties to the 
		entry points of Resource components to be executed via a Device's execute operation.

		The execute parameter for the Naming Context IOR is inserted into a CF Properties type. 
		The CF Properties ID element is set to "NAMING_CONTEXT_IOR" and the CF Properties value 
		element set to the stringified IOR of a naming context to which the component will bind. 
		The create operation creates any naming contexts that do not exist to which the component 
		will bind to the Naming Context IOR. The structure of the naming contxt path is "/ DomainName  
		/ [optional naming context sequences]". In the naming context path, each "slash" (/) represents 
		a separate naming context. 
		The execute parameter of Name Binding is inserted into a CF Properties type. The CF Properties 
		ID element is set to "NAME_BINDING" and CF Properties value element set to a string in the format 
		of "ComponentName_UniqueIdentifier".  The ComponentName value is the SAD componentinstantiation 
		findcomponent namingservice element's name attribute. The UniqueIdentifier is determined by the 
		implementation.  The Name Binding parameter is used by the component to bind its object reference 
		to the Naming Context IOR parameter.
		The create operation uses "ComponentName_UniqueIdentifier" to retrieve the component's object 
		reference from the Naming Context IOR (See also section 3.2.1.3.).  Due to the dynamics of 
		bind and resolve to CORBA Naming Service, the create operation should provide sufficient 
		attempts to retrieve component object references from CORBA Naming Service prior to generating an exception.

		For the component identifier execute parameter, the create operation is inserted in a CF Properties type. 
		The CF Properties ID element is set to "COMPONENT_IDENTIFIER" and the CF Properties value element to 
		the string format of Component_Instantiation_Identifier:Application_Name.  The Component_Instantiation_Identifier 
		is created using the componentinstantiation element id attribute for the component in the application's 
		SAD file.  The Application_Name field is identical to the create operation's input name parameter.  
		The Application_Name field provides a specific instance qualifier for executed Resource components.


		The create operation passes the componentinstantiation element "execparam" properties that have 
		values as parameters to execute operation.  The create operation passes "execparam" parameters 
		values as string values.
		The create operation, in order, initializes Resources, then establishes connections for 
		Resources, and finally configures the Resources.

		The create operation will only configure the application's assemblycontroller component.
		The create operation initializes an Application component provided the component 
		implements the LifeCycle interface.
		The create operation configures an application's assemblycontroller component provided 
		the assemblycontroller has configure readwrite or writeonly properties with values.  
		The create operation uses the union of the input initConfiguration properties of the create 
		operation and the assemblycontroller's componentinstantiation writeable "configure" properties 
		that have values.  The input initConfiguration parameter has precedence over the assemblycontroller's 
		writeable "configure" property values. The create operation, when creating a component from a 
		ResourceFactory, passes the componentinstantiation componentresoursefactoryref element 
		"factoryparam" properties that have values as qualifiers parameters to the referenced 
		ResourceFactory component's createResource operation.

		The create operation interconnects Application components' (Resources' or Devices') 
		ports in accordance with the SAD. The create operation obtains Ports in accordance 
		with the SAD via Resource getPort operation. The create operation uses the SAD connectinterface 
		element id attribute as the unique identifier for a specific connection when provided.  
		The create operation creates a connection ID when no SAD connectinterface element attribute 
		id is specified for a connection. The create operation obtains a Resource in accordance 
		with the SAD via the CORBA Naming Service or a ResourceFactory.. The ResourceFactory can be 
		obtained by using the CORBA Naming Service. 
		The create operation  passes, with invocation of each ResourceFactory createResource operation, 
		the ResourceFactory configuration properties associated with that Resource as dictated by the SAD.

		The dependencies to Log, FileManager, FileSystem, CORBA Event Service, and CORBA Naming Service 
		will be specified as connections in the SAD using the domainfinder element.  The create operation 
		will establish these connections. For connections established for a CORBA Event Service's event 
		channel, the create operation connects a CosEventComm PushConsumer or PushSupplier object to the 
		event channel as specified in the SAD's domainfinder element. If the event channel does not exist, 
		the create operation creates the event channel. 
		If the Application is successfully created, the create operation shall return an Application component 
		reference for the created Application.  A sequence of created Application references can be obtained 
		using the DomainManager's readonly applications attribute.

		The create operation, upon successful Application creation, writes an ADMINISTRATIVE_EVENT log record.
		The create operation, upon unsuccessful Application creation, writes a FAILURE_ALARM log record.
		The dependencies to Log, FileManager, and FileSystem will appear as connections in the 
		SAD using the domainfinder element.  The create operation will establish these connections. 
		The create operation, upon successful Application creation, sends an event to the Outgoing Domain 
		Management event channel with event data consisting of a DomainManagementObjectAddedEventType. 
		The event data will be populated as follows:
		1.	The producerId is the identifier attribute of the ApplicationFactory.
		2.	The sourceId is the identifier attribute of the created Application.
		3.	The sourceName is the anme attribute of the created Application.
		4.	The sourceIOR is the Application component reference for the created Application.
		5.	The sourceCategory is APPLICATION.

 
		The create operation raises the CreateApplicationRequestError exception when the 
		parameter CF DeviceAssignmentSequence contains one (1) or more invalid Application 
		component to device assignment(s).

		The create operation raises the CreateApplicationError exception when the create request 
		is valid but the Application can not be successfully instantiated due to internal processing error(s).

		The create operation raises the InvalidInitConfiguration exception when the input 
		initConfiguration parameter is invalid.  The InvalidInitConfiguration invalidPropertiesl 
		identifies the property that is invalid.
		@roseuid 38B7D97BCF98 */
		Application create (
			in string name,
			in Properties initConfiguration,
			in DeviceAssignmentSequence deviceAssignments
			)			
			raises (CreateApplicationError, CreateApplicationRequestError, InvalidInitConfiguration);
			
	};
  
	/* The Application delegates the implementation of the inherited Resource
	operations (runTest, start, stop, configure, and query) to the Application's
	Resource component (Assembly Controller) identified by the Application's SAD
	assemblycontroller element..  The Application propagates exceptions raised
	by the Application's Assembly Controller's operations.  The initialize operation is
	not propagated to the Application's components or its Assembly Controller.
	The intialize operation causes no action within an Application.
	
	The releaseObject operation terminates execution of the Application,
	returns all allocated computing resources, and de-allocates the Resources'
	capabilities in use by the devices associated with Application.  Before terminating,
	the Application removes the message connectivity with its associated
	Applications (e.g.  Ports, Resources, and Logs) in the domain.
	
	For each Application component not created by a ResourceFactory,
	the releaseObject operation  releases the component by utilizing the
	Resources's releaseObject operation.  If the component was created by a
	ResourceFactory, the releaseObject operation releases the component
	by the ResourceFactory releaseResource operation. The releaseObject operation
	shutdowns a ResourceFactory when no more Resources are managed by the
	ResourceFactory.
	
	For each allocated device capable of operation execution, the releaseObject
	operation terminates all processes / tasks of the Application's components
	utilizing the Device's terminate operation.
	
	For each allocated device capable of memory function, the releaseObject operation
	de-allocates the memory associated with Application's component instances
	utilizing the Device's unload operation.
	
	The releaseObject operation deallocates the Devices that are associated
	with the Application being released, based on the Application's Software Profile.
	The actual devices deallocated (Device::deallocateCapacity) will reflect changes
	in capacity based upon component capacity requirements deallocated from them,
	which may also cause state changes for the Devices.
	
	The Application releases all client component references to the Application
	components.
	
	The releaseObject operation disconnects Ports from other Ports that have
	been connected based upon the software profile.
	
	The releaseObject operation disconnects consumers and producers
	from a CORBA Event Service's event channel based upon the software profile.
	The releaseObject operation may destroy a CORBA Event Service's event channel
	when no more consumers and producers are connected to it.
	For components (e.g., Resource, ResourceFactory) that are registered with
	Naming Service, the releaseObject operation unbinds those components and
	destroy the associated naming contexts as necessary from the Naming Service.
	The releaseObject operation for an application disconnects Ports first, then
	release the Resources and ResourceFactories, then call the terminate operation,
	and lastly call the unload operation on the devices.
	
	The releaseObject operation, upon successful Application release, writes an
	ADMINISTRATIVE_EVENT log record.
	The releaseObject operation, upon unsuccessful Application release, writes a
	FAILURE_ALARM log record.
	The releaseObject operation, upon successful Application release, sends an
	event to the Outgoing Domain Management event channel with event data
	consisting of a DomainManagementObjectRemovedEventType. The event data
	will be populated as follows:
	1.	The producerId is the identifier attribute of the released Application.
	2.	The sourceId is the identifier attribute of the released Application.
	3.	The sourceName is the name attribute of the released Application.
	4.	The sourceCategory is APPLICATION */
		
  
	interface Application : Resource {
		/* The ComponentProcessIdType defines a type for associating a component with its process ID.  
		This type can be used to retrieve a process ID for a specific component. */
		
		struct ComponentProcessIdType {
			/* The componentId is a ID of a component that corresponds to the application's SAD 
			componentinstantiation's ID attribute value. */
			string componentId;
			/* The process ID of the executable component. */
			unsigned long processId;
		};
		
		/* The ComponentProcessIdSequence type defines an unbounded sequence of components' process IDs. */
		
		typedef sequence <ComponentProcessIdType> ComponentProcessIdSequence;
		
		/* The ComponentElementType defines a type for associating a component with an element (e.g., 
		naming context, implementation ID). */
		
		struct ComponentElementType {
			/* The componentId is a ID of a component that corresponds to the application's SAD 
			componentinstantiation's ID attribute value. */
			string componentId;
			/* The element ID that is associated with component ID. */
			string elementId;
		};
		
		/* The componentElementSequence defines an unbounded sequence of ComponentElementTypes. */
		
		typedef sequence <ComponentElementType> ComponentElementSequence;
		
		/* The componentNamingContexts attribute contains the list of components' 
		Naming Service Context within the Application for those components using CORBA Naming Service. */
		
		readonly attribute ComponentElementSequence componentNamingContexts;
		/* The componentProcessIds attribute contains the list of components' process IDs within the 
		Application for components that are executing on a device. */
		
		readonly attribute ComponentProcessIdSequence componentProcessIds;
		/* The componentDevices attribute shall contain a list of devices which each component either 
		uses, is loaded on or is executed on.  Each component (componentinstantiation element in the 
		Application's software profile) is associated with a device. */
		
		readonly attribute DeviceAssignmentSequence componentDevices;
		/* The componentImplementations attribute contains the list of components' SPD implementation 
		IDs within the Application for those components created. */
		
		readonly attribute ComponentElementSequence componentImplementations;
		/* This attribute is the XML profile information for the application.  The string value contains 
		either a profile element with a file reference to the SAD profile file or the actual xml for the 
		SAD profile.  Files referenced within a profile will have to be obtained via a FileManager.  
		The Application will have to be queried for profile information for Component files that are 
		referenced by an ID instead of a file name. */
		
		readonly attribute string profile;
		/* This name attribute contains the name of the created Application.  The ApplicationFactory 
		interface's create operation name parameter provides the name content. */
		
		readonly attribute string name;
	};
}; //module CF
#endif
